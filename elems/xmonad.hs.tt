-- ────────────────────────────────────────────────────────────────────────────┐
--                                                                             │
-- Name:    elems/xmonad.hs.tt                                                 │
-- Summary: XMonad configuration.                                              │
-- Authors:                                                                    │
--   - Alessandro Molari <molari.alessandro@gmail.com> (alem0lars)             │
--                                                                             │
-- Project:                                                                    │
--   - Homepage:        https://github.com/alem0lars/configs-xmonad            │
--   - Getting started: see README.md in the project root folder               │
--                                                                             │
-- License: Apache v2.0 (see below)                                            │
--                                                                             │
-- ────────────────────────────────────────────────────────────────────────────┤
--                                                                             │
-- Licensed to the Apache Software Foundation (ASF) under one more contributor │
-- license agreements.  See the NOTICE file distributed with this work for     │
-- additional information regarding copyright ownership. The ASF licenses this │
-- file to you under the Apache License, Version 2.0 (the "License"); you may  │
-- not use this file except in compliance with the License.                    │
-- You may obtain a copy of the License at                                     │
--                                                                             │
--   http://www.apache.org/licenses/LICENSE-2.0                                │
--                                                                             │
-- Unless required by applicable law or agreed to in writing, software         │
-- distributed under the License is distributed on an "AS IS" BASIS, WITHOUT   │
-- WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.            │
-- See the License for the specific language governing permissions and         │
-- limitations under the License.                                              │
--                                                                             │
-- ────────────────────────────────────────────────────────────────────────────┤
<% define_locals do
  variable :"xmonad.terminal.open_cmd", as: :term_open_cmd
  variable :"xmonad.terminal.run_cmd",  as: :term_run_cmd
  variable :"xmonad.workspace_dir",     as: :workspace_dir

  variable :"font.name", as: :font_name
  variable :"font.size", as: :font_size, type: :int
end %>
-- ────────────────────────────────────────────────────────────────────────────┘


-- ┌───────────────────────────────────────────────────────────────────────────┐
-- │                            TABLE OF CONTENTS                              │
-- ├┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┤
-- │                                                                           │
-- │ •1• imports                                                               │
-- │ •2• xconfig                                                               │
-- │ •3• types                                                                 │
-- │                                                                           │
-- └───────────────────────────────────────────────────────────────────────────┘


-- ───────────────────────────────────────────────────────────── imports •1• ──┐

import qualified Data.Map as M

import XMonad

import qualified XMonad.Actions.Search    as AS
import qualified XMonad.Actions.FloatSnap as AFS

import qualified XMonad.Hooks.DynamicLog   as HDL
import qualified XMonad.Hooks.EwmhDesktops as HEWMH
import qualified XMonad.Hooks.ICCCMFocus   as HICCCMF
import qualified XMonad.Hooks.ManageDocks  as HMD
import qualified XMonad.Hooks.ManageHelpers as HMH
import qualified XMonad.Hooks.SetWMName    as HWMN
import qualified XMonad.Hooks.UrgencyHook  as HU

import qualified XMonad.Layout.MultiToggle           as LMT
import qualified XMonad.Layout.MultiToggle.Instances as LMTI
import qualified XMonad.Layout.Decoration            as LD
import qualified XMonad.Layout.NoBorders             as LNB
import qualified XMonad.Layout.Reflect               as LR
import qualified XMonad.Layout.Tabbed                as LT
import qualified XMonad.Layout.PerWorkspace          as LPW
import qualified XMonad.Layout.WorkspaceDir          as LWD

import qualified XMonad.Prompt           as P
import qualified XMonad.Prompt.Man       as PM
import qualified XMonad.Prompt.Ssh       as PS
import qualified XMonad.Prompt.Workspace as PW

import qualified XMonad.StackSet as SS

import qualified XMonad.Util.NamedScratchpad as SP
import qualified XMonad.Util.Run as R
import qualified XMonad.Util.EZConfig as EZ

-- ────────────────────────────────────────────────────────────────────────────┘


-- ───────────────────────────────────────────────────────────── xconfig •2• ──┐

main = do
    myStatusBarHandle <- R.spawnPipe myStatusBarCmd
    xmonad $ HU.withUrgencyHook HU.NoUrgencyHook
           $ HEWMH.ewmh
           $ xConfig myStatusBarHandle
  where
    xConfig myStatusBarHandle = defaultConfig
      { XMonad.layoutHook         = myLayoutHook
      , XMonad.manageHook         = myManageHook
      , XMonad.handleEventHook    = myHandleEventHook
      , XMonad.logHook            = myLogHook myStatusBarHandle
      , XMonad.startupHook        = myStartupHook
      , XMonad.workspaces         = myWorkspaces
      , XMonad.modMask            = myModMask
      , XMonad.focusFollowsMouse  = myFocusFollowsMouse
      , XMonad.clickJustFocuses   = myClickJustFocuses
      , XMonad.borderWidth        = myBorderWidth
      , XMonad.normalBorderColor  = myColorHex myNormalBorderColor
      , XMonad.focusedBorderColor = myColorHex myFocusedBorderColor
      , XMonad.terminal           = myTerminal
      }
      `EZ.additionalKeys`          myKeyBindings
      `EZ.additionalMouseBindings` myMouseBindings

-- ─────────────────────────────────────────────────────────── layouts •2.1• ──┤

myLayoutHook = LNB.smartBorders . HMD.avoidStruts
    $ LWD.workspaceDir myWorkspaceDir
    $ LMT.mkToggle1 LMTI.NBFULL    -- switch to full with no borders
    $ LMT.mkToggle1 LR.REFLECTX    -- reflect x-axis
    $ LMT.mkToggle1 LR.REFLECTY    -- reflect y-axis
    $ LMT.mkToggle1 LMTI.NOBORDERS -- remove borders
    $ LMT.mkToggle1 LMTI.MIRROR    -- mirror the current layout
    $ LPW.onWorkspace (myWorkspaces !! 0) myRefLayouts
    $ LPW.onWorkspace (myWorkspaces !! 1) myWflowLayouts
    $ LPW.onWorkspace (myWorkspaces !! 2) myWflowLayouts
    $ LPW.onWorkspace (myWorkspaces !! 3) myWflowsuppLayouts
    $ LPW.onWorkspace (myWorkspaces !! 4) myOrgLayouts
    $ LPW.onWorkspace (myWorkspaces !! 5) mySocialLayouts
    $ LPW.onWorkspace (myWorkspaces !! 6) myPlayLayouts
    $ LPW.onWorkspace (myWorkspaces !! 7) myMgmtLayouts
    $ LPW.onWorkspace (myWorkspaces !! 8) myTmpLayouts
    $ LPW.onWorkspace (myWorkspaces !! 9) myComboLayouts
    $ myDefaultLayouts
  where
    myWorkspaceDir = "<%= local!(:workspace_dir) %>"

    -- Layout groups
    myTabbedLayout = LT.tabbed LT.shrinkText $ LT.defaultTheme
      { LT.inactiveBorderColor = myColorHex myNormalBorderColor
      , LT.activeBorderColor   = myColorHex myFocusedBorderColor
      , LT.activeTextColor     = myColorHex myFocusedTextColor
      , LT.urgentBorderColor   = myColorHex myUrgentBorderColor
      , LT.urgentTextColor     = myColorHex myUrgentTextColor
      }
    myRefLayouts = myTabbedLayout ||| myGridLayout
    myWflowLayouts = myOneBigLayout ||| myMosaicLayout ||| myGridLayout ||| myTabbedLayout
    myWflowsuppLayouts = myTabbedLayout ||| myGridLayout ||| myOneBigLayout ||| myMosaicLayout
    myOrgLayouts = myTabbedLayout ||| myGridLayout
    mySocialLayouts = myTabbedLayout ||| myGridLayout
    myPlayLayouts = myTabbedLayout ||| myGridLayout
    myMgmtLayouts = myGridLayout ||| myOneBigLayout ||| myTabbedLayout
    myTmpLayouts = myGridLayout ||| myTabbedLayout
    myComboLayouts = myTabbedLayout
    myDefaultLayouts = myWflowLayouts

    -- Layout definitions
    myCrossLayout     = Full -- TODO simpleCross
    myFullLayout      = Full -- TODO Full
    myAccordionLayout = Full -- TODO Accordion
    myGridLayout      = Full -- TODO Grid
    mySpiralLayout    = Full -- TODO spiral (1/2)
    myMosaicLayout    = Full -- TODO mosaic 2 [3, 2]
    myFloatLayout     = Full -- TODO simpleFloat
    myOneBigLayout    = Full -- TODO OneBig 0.6 0.74

-- ──────────────────────────────────────────────────────── workspaces •2.2• ──┤

myWorkspaces =
    zipWith ((++) . show) myWorkspaceIds (map (mySeparator ++) myWorkspaceNames)
  where
    myWorkspaceIds = [ myDelimiter ++ (show myWorkspaceIndex)  ++ myDelimiter
                     | myWorkspaceIndex <- [1..]]
    myDelimiter = "•"
    mySeparator = " "
    myWorkspaceNames =
      [ "ref"
      , "wflow_0"
      , "wflow_1"
      , "wflow_supp_0"
      , "org"
      , "social"
      , "play"
      , "mgmt"
      , "tmp"
      , "combo"
      ]

-- ────────────────────────────────────────────────────────── log hook •2.3• ──┤

myLogHook h = HICCCMF.takeTopFocus >> HDL.dynamicLogWithPP (myStatusBarPP h)

-- ───────────────────────────────────────────────────────── statusbar •2.4• ──┤

myStatusBarCmd = "/usr/bin/xmobar"

myStatusBarPP h = HDL.defaultPP
    { HDL.ppCurrent         = formatStatus myCurrentColor myCurrentSymbols
    , HDL.ppVisible         = formatStatus myVisibleColor myVisibleSymbols
    , HDL.ppHidden          = formatStatus myHiddenColor myHiddenSymbols
    , HDL.ppHiddenNoWindows = formatStatus myEmptyColor myEmptySymbols
    , HDL.ppUrgent          = formatStatus myUrgentColor myUrgentSymbols
    , HDL.ppLayout          = formatStatus myLayoutColor myLayoutSymbols
                            . take 16 -- Maximum layout name ( TODO to be computed automatically)
                            . (++ repeat ' ')
    , HDL.ppSep    = "  "
    , HDL.ppWsSep  = " "
    , HDL.ppTitle  = take 0
    , HDL.ppOutput = R.hPutStrLn h
    }
  where
    -- utility function: surround with symbols and apply colors
    formatStatus colorSpec symbolSpec = uncurry HDL.xmobarColor (myMapTuple myColorHex colorSpec)
                                      . uncurry HDL.wrap symbolSpec

    myCurrentColor   = (myBgColor, green myColors)
    myCurrentSymbols = (" [", "] ")

    myVisibleColor   = (myBgColor, cyan myColors)
    myVisibleSymbols = (" |", "| ")

    myHiddenColor   = (myBgColor, lightGrey myColors)
    myHiddenSymbols = (" +", "  ")

    myEmptyColor   = (myBgColor, grey myColors)
    myEmptySymbols = ("  ", "  ")

    myUrgentColor   = (orange myColors, myBgColor)
    myUrgentSymbols = (" ⚠ ", " ⚠ ")

    myLayoutColor   = (myBgColor, magenta myColors)
    myLayoutSymbols = (" ▄︻̷̿┻̿═━一 ", " # ")

-- ────────────────────────────────────────────────────── startup hook •2.5• ──┤

myStartupHook = HEWMH.ewmhDesktopsStartup >> HWMN.setWMName "LG3D"

-- ───────────────────────────────────────────────── handle event hook •2.6• ──┤

myHandleEventHook = handleEventHook defaultConfig
                <+> HMD.docksEventHook
                <+> HEWMH.ewmhDesktopsEventHook
                <+> HEWMH.fullscreenEventHook

-- ─────────────────────────────────────────────────────── manage hook •2.7• ──┤

myManageHook = basicManageHook <+> manageHook defaultConfig
basicManageHook = composeAll . concat $
  [ [HMD.manageDocks]
  , [SP.namedScratchpadManageHook myScratchpads]
  , [HMH.isFullscreen --> HMH.doFullFloat]
  , [HMH.isDialog --> doFloat]
  , [checkXWindowQuery q --> doFloat   | q      <- myFloats]
  , [checkXWindowQuery q --> doShift w | (q, w) <- myShifts]
  ]
  where
    myFloats =
      [ XWindowClass "Arandr"
      , XWindowClass "Pavucontrol"
      , XWindowClass "Copyq"
      , XWindowClass "XFontSel"
      , XWindowClass "Xmessage"
      , XWindowTitle "Save As..."
      ]

    myShifts =
      [ (XWindowClass "firefox", myWorkspaces !! 0)
      ]

-- ─────────────────────────────────────────────────────── scratchpads •2.8• ──┤

myScratchpadSize = SS.RationalRect (1/4) (1/4) (1/2) (1/2)

myScratchpadFloat = SP.customFloating myScratchpadSize

myScratchpads =
    [ SP.NS "term" myTerminal (title =? "term") myScratchpadFloat
    , SP.NS "top" (myRunCmd "htop") (title =? "htop") myScratchpadFloat
    <% if has_feature? :python %>
    , SP.NS "ipy" (myRunCmd "ipython") (title =? "ipython") myScratchpadFloat
    <% end %>
    <% if has_feature? :ruby %>
    , SP.NS "irb" (myRunCmd "irb") (title =? "irb") myScratchpadFloat
    <% end %>
    <% if has_feature? :haskell %>
    , SP.NS "ghci" (myRunCmd "ghci") (title =? "ghci") myScratchpadFloat
    <% end %>
    ]
  where
    myRunCmd cmd = "<%= local! :term_run_cmd %> " ++ cmd

-- ────────────────────────────────────────────────────── key bindings •2.9• ──┤

myModMask = mod4Mask

myKeyBindings = [] -- TODO implement

mySearchEnginesKeymap method = M.fromList
  [ ((0, xK_a), method AS.alpha)
  , ((0, xK_c), method AS.codesearch)
  , ((0, xK_d), method AS.dictionary)
  , ((0, xK_g), method AS.google)
  , ((0, xK_H), method AS.hackage)
  , ((0, xK_h), method AS.hoogle)
  , ((0, xK_i), method AS.images)
  , ((0, xK_m), method AS.maps)
  , ((0, xK_M), method AS.mathworld)
  , ((0, xK_s), method AS.scholar)
  , ((0, xK_t), method AS.thesaurus)
  , ((0, xK_W), method AS.wayback)
  , ((0, xK_w), method AS.wikipedia)
  , ((0, xK_y), method AS.youtube)
  , ((0, xK_u), method AS.multi)
  ]

myScratchpadKeymap =
  [ ("M-a t", SP.namedScratchpadAction myScratchpads "term")
  , ("M-a i", SP.namedScratchpadAction myScratchpads "top")
  <% if has_feature? :python %>
  , ("M-a p", SP.namedScratchpadAction myScratchpads "ipy")
  <% end %>
  <% if has_feature? :ruby %>
  , ("M-a r", SP.namedScratchpadAction myScratchpads "irb")
  <% end %>
  <% if has_feature? :haskell %>
  , ("M-a h", SP.namedScratchpadAction myScratchpads "ghci")
  <% end %>
  , ("M-a w",   PW.workspacePrompt myXpConfig (windows . SS.greedyView))
  , ("M-a M-w", PW.workspacePrompt myXpConfig (windows . SS.shift))
  , ("M-a m",   PM.manPrompt  myXpConfig)
  , ("M-a d",   LWD.changeDir myXpConfig)
  , ("M-a s",   PS.sshPrompt  myXpConfig)
  ]

-- ─────────────────────────────────────────────────── mouse bindings •2.10• ──┤

myMouseBindings =
    [ ((mod4Mask,               button1), myMoveWindow)
    , ((mod4Mask .|. shiftMask, button1), myExpandWindow)
    , ((mod4Mask,               button3), myResizeWindow)
    ]
  where
    myMoveWindow =
      \w -> focus w >>
            mouseMoveWindow w >>
            AFS.snapMagicMove (Just 50) (Just 50) w
    myExpandWindow =
      \w -> focus w >>
            mouseMoveWindow w >>
            AFS.snapMagicResize [AFS.L, AFS.R, AFS.U, AFS.D] (Just 50) (Just 50) w
    myResizeWindow =
      \w -> focus w >>
            mouseResizeWindow w >>
            AFS.snapMagicResize [AFS.R, AFS.D] (Just 50) (Just 50) w

-- ───────────────────────────────────────────────────────────── misc •2.11• ──┤

myTerminal = "<%= local! :term_open_cmd %>"

-- whether focus follows the mouse pointer
myFocusFollowsMouse = True

-- whether a mouse click select the focus or is just passed to the window
myClickJustFocuses = True

-- ─────────────────────────────────────────────────────────── prompt •2.12• ──┤

myXpConfig = P.defaultXPConfig
  { P.font        = myFontXft myFont
  , P.bgColor     = myColorHex myBgColor
  , P.fgColor     = myColorHex myFgColor
  , P.bgHLight    = myColorHex myBgHighlightColor
  , P.fgHLight    = myColorHex myFgHighlightColor
  , P.borderColor = myColorHex myNormalBorderColor
  , P.position    = P.Top
  }

-- ─────────────────────────────────────────────────────────── colors •2.13• ──┤

myColors = MyColorPalette
  { darkerGrey   = Hex "151515"
  , darkGrey     = Hex "1C1C1C"
  , grey         = Hex "404040"
  , lightGrey    = Hex "888888"
  , lighterGrey  = Hex "E8E8D3"
  , darkRed      = Hex "B85335"
  , red          = Hex "CF6A4C"
  , darkGreen    = Hex "799D6A"
  , green        = Hex "99AD6A"
  , orange       = Hex "FFB964"
  , yellow       = Hex "FAD07A"
  , blue         = Hex "5771A0"
  , darkBlue     = Hex "375385"
  , magenta      = Hex "8787AF"
  , lightMagenta = Hex "C6B6EE"
  , cyan         = Hex "668799"
  , lightCyan    = Hex "8FBFDC"
  }

myNormalBorderColor  = grey myColors

myFocusedBorderColor = darkBlue myColors
myFocusedTextColor   = cyan myColors

myUrgentBorderColor = magenta myColors
myUrgentTextColor   = lightMagenta myColors

myBgColor = darkerGrey myColors
myFgColor = lightGrey myColors

myBgHighlightColor = darkGrey myColors
myFgHighlightColor = lighterGrey myColors

-- ──────────────────────────────────────────────────────────── fonts •2.14• ──┤

myFont = MyFont
  { name = "<%= local! :font_name %>"
  , size = <%= local! :font_size %>
  }

-- ──────────────────────────────────────────────────────────── sizes •2.15• ──┤

myBorderWidth = 1

-- ────────────────────────────────────────────────────────────────────────────┘


-- ─────────────────────────────────────────────────────────────── types •3• ──┐

data MyFont = MyFont
  { name :: String
  , size :: Int
  }

myFontXft (MyFont name size) = "xft:" ++ name ++ "-" ++ show size

data MyColor = Hex String

myColorHex :: MyColor -> String
myColorHex (Hex hex) = hex

data MyColorPalette = MyColorPalette
  { darkerGrey   :: MyColor
  , darkGrey     :: MyColor
  , grey         :: MyColor
  , lightGrey    :: MyColor
  , lighterGrey  :: MyColor
  , darkRed      :: MyColor
  , red          :: MyColor
  , darkGreen    :: MyColor
  , green        :: MyColor
  , orange       :: MyColor
  , yellow       :: MyColor
  , blue         :: MyColor
  , darkBlue     :: MyColor
  , magenta      :: MyColor
  , lightMagenta :: MyColor
  , cyan         :: MyColor
  , lightCyan    :: MyColor
  }

data XWindowQuery a = XWindowClass    a
                    | XWindowResource a
                    | XWindowTitle    a

checkXWindowQuery (XWindowClass    a) = className =? a
checkXWindowQuery (XWindowTitle    a) = title     =? a
checkXWindowQuery (XWindowResource a) = resource  =? a

myMapTuple :: (a -> b) -> (a, a) -> (b, b)
myMapTuple f (a1, a2) = (f a1, f a2)

-- ────────────────────────────────────────────────────────────────────────────┘


-- vim: set filetype=eruby.haskell :
